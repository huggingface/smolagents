# 에이전트란 무엇인가요? 🤔

## 에이전트 시스템 소개

AI를 사용하는 모든 효율적인 시스템은 LLM에 실제 세계에 대한 어떤 종류의 접근을 제공해야 합니다: 예를 들어 외부 정보를 얻기 위해 검색 도구를 호출할 수 있는 가능성, 또는 작업을 해결하기 위해 특정 프로그램에 작용할 수 있는 기능입니다. 다시 말해서, LLM은 ***주체성(agency)***을 가져야 합니다. 에이전트 프로그램은 LLM의 외부 세계로 가는 관문입니다.

> [!TIP]
> AI 에이전트는 **LLM 출력이 워크플로우를 제어하는 프로그램**입니다.

LLM을 활용하는 모든 시스템은 LLM 출력을 코드로 통합합니다. LLM의 입력이 코드 워크플로우에 미치는 영향은 시스템에서 LLM의 주체성(agency) 수준입니다.

이 정의에서 "에이전트"는 0 또는 1의 이산 정의가 아닙니다: 대신 "주체성"은 워크플로우에서 LLM에 얼마나 많은 권한을 부여하느냐에 따라 연속 스펙트럼에서 발전합니다.

아래 표에서 주체성이 시스템 간에 어떻게 변할 수 있는지 확인하세요:

| 주체성 수준 | 설명 | 짧은 이름 | 예시 코드 |
| --- | --- | --- | --- |
| ☆☆☆ | LLM 출력이 프로그램 흐름에 영향을 주지 않음 | 단순 처리기 | `process_llm_output(llm_response)` |
| ★☆☆ | LLM 출력이 if/else 스위치를 제어 | 라우터 | `if llm_decision(): path_a() else: path_b()` |
| ★★☆ | LLM 출력이 함수 실행을 제어 | 도구 호출 | `run_function(llm_chosen_tool, llm_chosen_args)` |
| ★★☆ | LLM 출력이 반복 및 프로그램 연속을 제어 | 다중 단계 에이전트 | `while llm_should_continue(): execute_next_step()` |
| ★★★ | 하나의 에이전트 워크플로우가 다른 에이전트 워크플로우를 시작할 수 있음 | 다중 에이전트 | `if llm_trigger(): execute_agent()` |
| ★★★ | LLM이 코드로 작동하며 자체 도구를 정의하거나 다른 에이전트를 시작할 수 있음 | 코드 에이전트 | `def custom_tool(args): ...` |

## ✅ 에이전트를 사용해야 할 때 / ⛔ 피해야 할 때

에이전트는 LLM이 앱의 워크플로우를 결정해야 할 때 유용합니다. 하지만 종종 과도합니다. 질문은 다음과 같습니다: 현재 작업을 효율적으로 해결하기 위해 정말로 워크플로우의 유연성이 필요한가요?

## Why `smolagents`?

체인이나 라우터와 같은 일부 저수준 에이전트 사용 사례의 경우, 모든 코드를 직접 작성할 수 있습니다. 이렇게 하면 훨씬 더 나을 것입니다. 왜냐하면 당신의 시스템을 더 잘 제어하고 이해할 수 있게 해주기 때문입니다.

## 코드 에이전트

다중 단계 에이전트에서, 각 단계에서 LLM은 외부 도구에 대한 호출 형식의 작업을 작성할 수 있습니다. [여러 개의](https://huggingface.co/papers/2402.01030) [연구](https://huggingface.co/papers/2411.01747) [논문](https://huggingface.co/papers/2401.00812)에서 LLM 작업을 코드 스니펫으로 작성하는 것이 더 자연스럽고 유연한 방식임을 보여주었습니다.

그 이유는 간단합니다: *우리는 코드 언어를 컴퓨터가 수행하는 작업을 표현하기 위해 특별히 만들었습니다*.